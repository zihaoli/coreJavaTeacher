1.抽象类
   a.抽象方法---->有些行为确实存在，但是必须到子类中才会有具体实现
                          那么这个时候，父类中只需要有声明即可，不需要有实现
      如何声明呢，abstract
   b.如果一个类中含有了抽象方法，该类就是抽象类
      必须用abstract 关键字声明
   c.抽象类就是用来继承的。
     当一个类继承抽象类的时候，必须重写抽象类的抽象方法，
     如果不重写，那么该类自己就会变成抽象类，必须用abstract声明
   d.抽象类不能实例化，只能实例化其子类的对象
      只要看到抽象类的引用，引用的一定是其子类的实例
      如果看到函数的参数是抽象类，那么调用函数是传递的是该抽象类
      子类的对象；如果看到函数的返回值类型是抽象，那么返回的
      一定是该抽象类子类的实例对象
      
      
 2.final 关键字
    修饰变量
         该变量只能赋值一次
         如果作为成员变量必须有初始值（定义初始化or构造函数初始化)
    函数 
       final修饰函数，该函数不能被重写
    类
       final修饰类，该类不能被继承，这个类是断子绝孙的   
     
      final 和abstract 是不能一起使用的
      private和abstract也不能组合
    
    
 3.接口
   接口是一个标准，更多体现能干什么  can-do
   抽象类是体现的继承     is-a关系
   a.接口用interface 关键字声明---->地位等价于类的地位,同样会产生.class文件
   b.接口中所有的方法都是public abstract 的，即使没有这样声明
      所以所有方法在接口中都不能有实现
   c.定义了一个CanFly接口，我们认为在编程中，实现了这个接口的
      类的对象 就是具备了飞功能
      实现的时候用implements 关键字
      实现接口，必须重写接口中的抽象方法，否则自己变成了抽象类，
      需要用abstract 声明
    d.接口是不能实例化的，接口中是不能有构造函数的，全部都是抽象
      的方法
       看到接口的引用，引用的一定是实现了该接口的类的对象
    e.如何理解接口
       主板制造商  ---->主板需要插入内存、显卡 ...  ...
        本来的原理是：主板制造商需要等待内存制造商、显卡制造
        商把内存弄出来，显卡弄出来才知道如何去制造主板
        但是现实生活中并不是这样，内存，显卡都有标准，
        那么主板就不用等了，直接根据标准预留接口即可
        那么这个标准就是接口。MainBord/Memory/DisplayCard/Computer
   f. 一个类可以实现多个接口（具备多个标准，具备都个功能
                                            我即使u盘又是mp3)
        就需要实现接口中的所有方法
        一个类可以继承一个类同时实现多个接口
   g.java中是单一继承，但是接口与接口之间可以进行多继承，
      就是一个接口可以由多个接口继承而来
   h.接口中甚至可以没有任何方法，就是一套标准。 
      Serializable，Cloneable
   i. 接口中可以声明变量，接口中声明的变量都是
      public static final 的，即使没有这样声明
   k.接口中有非常多的方法，而我们再用的时候吗，每次
      只用个别的方法，非常麻烦，可以写一个适配器类见Demo10
       这种缺省适配器类一般都是抽象的，明确指定不需要对象
       
       什么是抽象类:只要是abstract声明的类，就是抽象类。
       
 4.内部类 （只要是类就会产生class文件)
   4.1成员内部类
        a.直接在外部类的其它成员中访问，创建内部类的对象(最简单最常用的)
        b.如果成员内部类访问权限为非private，直接访问就可以
           Outer.Inner inner = outer.new Inner(参数); (用得较少)
        c.类名.this   成员内部类中访问外部类的当前对象
   4.2静态内部类
        a.直接在外部类成员中访问(简单常用)
        b.如果非private 直接创建对象
           Outer.Inner inner = new Outer.Inner();
        c.静态内部类中只能访问外部类的静态成员。
   4.3 局部内部类
        一般声明在某个函数的内部，只在该函数内有效，
        一样会产生class文件
   4.4 匿名内部类---->（局部内部类的特殊情况)
        a.什么时候用？
           已经知道父类，获取其子类的实例对象
           已经知道接口，获取实现了该接口的类的对象
           匿名类在用的时候必须是直接获取该匿名类的对象
       b.怎么用?怎么样获取对象呢？
          公式：new 父类or接口（）
                    {
                         子类的实现or(实现了该接口的类的实现）
                    }
          公式得到的是匿名类的对象，实现了该接口（继承了该抽象类）的类的实例对象
    
      c.上面的公式看起来是一样，但是要注意有区别
             new 父类(可以给父类的构造函数传递参数){子类实现}
             接口不存在这个问题，接口是没有构造函数的。
            
  注意:在内部类中访问局部变量，该变量必须声明为final
        
        
        
        
        
    
    
    
    
    
    
    
    
    
    
    
    